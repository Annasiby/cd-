#include <stdio.h>
#include <string.h>

#define STATES 99
#define SYMBOLS 20

int N_symbols = 2;
int N_DFA_states = 6;
char *DFA_finals = "EF";
int DFAtab[STATES][SYMBOLS];

char StateName[STATES][STATES + 1];
int N_optDFA_states;
int OptDFA[STATES][SYMBOLS];
char NEW_finals[STATES + 1];

void load_DFA_table() {
    DFAtab[0][0] = 'B'; DFAtab[0][1] = 'C';
    DFAtab[1][0] = 'E'; DFAtab[1][1] = 'F';
    DFAtab[2][0] = 'A'; DFAtab[2][1] = 'A';
    DFAtab[3][0] = 'F'; DFAtab[3][1] = 'E';
    DFAtab[4][0] = 'D'; DFAtab[4][1] = 'F';
    DFAtab[5][0] = 'D'; DFAtab[5][1] = 'E';
}

void print_dfa_table(int tab[][SYMBOLS], int nstates, int nsymbols, char *finals) {
    int i, j;
    puts("\nDFA: STATE TRANSITION TABLE");
    printf("     | ");
    for (i = 0; i < nsymbols; i++) printf("  %c  ", '0' + i);
    printf("\n-----+--");
    for (i = 0; i < nsymbols; i++) printf("-----");
    printf("\n");
    for (i = 0; i < nstates; i++) {
        printf("  %c  | ", 'A' + i);
        for (j = 0; j < nsymbols; j++) {
            printf("  %c  ", tab[i][j]);
        }
        printf("\n");
    }
    printf("Final states = %s\n", finals);
}

char equiv_class_ndx(char ch, char stnt[][STATES + 1], int n) {
    for (int i = 0; i < n; i++)
        if (strchr(stnt[i], ch)) return i + '0';
    return -1;
}

char is_one_nextstate(char *s) {
    while (*s == '@') s++;
    char equiv_class = *s++;
    while (*s) {
        if (*s != '@' && *s != equiv_class) return 0;
        s++;
    }
    return equiv_class;
}

int state_index(char *state, char stnt[][STATES + 1], int n, int *pn, int cur) {
    if (!*state) return -1;
    char state_flags[STATES + 1];
    for (int i = 0; i < strlen(state); i++)
        state_flags[i] = equiv_class_ndx(state[i], stnt, n);
    state_flags[strlen(state)] = '\0';

    printf("   %d:[%s] --> [%s] (%s)\n", cur, stnt[cur], state, state_flags);

    int i;
    if ((i = is_one_nextstate(state_flags)))
        return i - '0';
    else {
        strcpy(stnt[*pn], state_flags);
        return (*pn)++;
    }
}

void get_next_state(char *nextstates, char *cur_states, int dfa[STATES][SYMBOLS], int symbol) {
    for (int i = 0; i < strlen(cur_states); i++)
        *nextstates++ = dfa[cur_states[i] - 'A'][symbol];
    *nextstates = '\0';
}

int init_equiv_class(char statename[][STATES + 1], int n, char *finals) {
    if (strlen(finals) == n) {
        strcpy(statename[0], finals);
        return 1;
    }

    strcpy(statename[1], finals);
    int j = 0;
    for (int i = 0; i < n; i++) {
        if (!strchr(finals, i + 'A'))
            statename[0][j++] = i + 'A';
    }
    statename[0][j] = '\0';
    return 2;
}

void chr_append(char *s, char ch) {
    int n = strlen(s);
    s[n] = ch;
    s[n + 1] = '\0';
}

void sort(char stnt[][STATES + 1], int n) {
    char temp[STATES + 1];
    for (int i = 0; i < n - 1; i++)
        for (int j = i + 1; j < n; j++)
            if (stnt[i][0] > stnt[j][0]) {
                strcpy(temp, stnt[i]);
                strcpy(stnt[i], stnt[j]);
                strcpy(stnt[j], temp);
            }
}

int split_equiv_class(char stnt[][STATES + 1], int i1, int i2, int n, int n_dfa) {
    char *old = stnt[i1], *vec = stnt[i2];
    char newstates[STATES][STATES + 1] = {{0}};
    int n2 = n, flag = 0;

    for (int i = 0; vec[i]; i++)
        chr_append(newstates[vec[i] - '0'], old[i]);

    for (int i = 0; i < n_dfa; i++) {
        if (newstates[i][0]) {
            if (!flag) {
                strcpy(stnt[i1], newstates[i]);
                flag = 1;
            } else {
                strcpy(stnt[n2++], newstates[i]);
            }
        }
    }

    sort(stnt, n2);
    return n2;
}

int set_new_equiv_class(char stnt[][STATES + 1], int n, int newdfa[][SYMBOLS], int n_sym, int n_dfa) {
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n_sym; j++) {
            int k = newdfa[i][j] - 'A';
            if (k >= n)
                return split_equiv_class(stnt, i, k, n, n_dfa);
        }
    return n;
}

int get_optimized_DFA(char stnt[][STATES + 1], int n, int dfa[][SYMBOLS], int n_sym, int newdfa[][SYMBOLS]) {
    int n2 = n;
    char nextstate[STATES + 1];

    for (int i = 0; i < n; i++)
        for (int j = 0; j < n_sym; j++) {
            get_next_state(nextstate, stnt[i], dfa, j);
            newdfa[i][j] = state_index(nextstate, stnt, n, &n2, i) + 'A';
        }

    return n2;
}

void print_equiv_classes(char stnt[][STATES + 1], int n) {
    printf("\nEQUIV. CLASS CANDIDATES:");
    for (int i = 0; i < n; i++)
        printf(" %d:[%s]", i, stnt[i]);
    printf("\n");
}

int is_subset(char *s, char *t) {
    while (*t)
        if (!strchr(s, *t++)) return 0;
    return 1;
}

void get_NEW_finals(char *newfinals, char *oldfinals, char stnt[][STATES + 1], int n) {
    for (int i = 0; i < n; i++)
        if (is_subset(oldfinals, stnt[i]))
            *newfinals++ = i + 'A';
    *newfinals = '\0';
}

int optimize_DFA(int dfa[][SYMBOLS], int n_dfa, int n_sym, char *finals, char stnt[][STATES + 1], int newdfa[][SYMBOLS]) {
    int n = init_equiv_class(stnt, n_dfa, finals), n2;

    while (1) {
        print_equiv_classes(stnt, n);
        n2 = get_optimized_DFA(stnt, n, dfa, n_sym, newdfa);
        if (n != n2)
            n = set_new_equiv_class(stnt, n, newdfa, n_sym, n_dfa);
        else break;
    }

    return n;
}

int main() {
    load_DFA_table();
    print_dfa_table(DFAtab, N_DFA_states, N_symbols, DFA_finals);

    N_optDFA_states = optimize_DFA(DFAtab, N_DFA_states, N_symbols, DFA_finals, StateName, OptDFA);
    get_NEW_finals(NEW_finals, DFA_finals, StateName, N_optDFA_states);

     print_dfa_table(OptDFA, N_optDFA_states, N_symbols, NEW_finals); 
}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX 100

int dfa[MAX][MAX];       // DFA transition table
int final[MAX];          // Final states
int reachable[MAX];      // Reachable states
int distinguishable[MAX][MAX]; // Table for distinguishable pairs
int state_count, symbol_count;

// DFS to mark reachable states
void dfs(int state) {
    if (reachable[state]) return;
    reachable[state] = 1;
    for (int a = 0; a < symbol_count; a++) {
        dfs(dfa[state][a]);
    }
}

// Step 1: Remove unreachable states
void find_reachable() {
    dfs(0); // assuming start state is q0
}

// Step 2: Table-filling algorithm
void mark_distinguishable() {
    for (int i = 0; i < state_count; i++) {
        for (int j = 0; j < i; j++) {
            if ((final[i] && !final[j]) || (!final[i] && final[j])) {
                distinguishable[i][j] = 1;
            }
        }
    }

    int changed;
    do {
        changed = 0;
        for (int i = 0; i < state_count; i++) {
            for (int j = 0; j < i; j++) {
                if (!distinguishable[i][j]) {
                    for (int a = 0; a < symbol_count; a++) {
                        int p = dfa[i][a], q = dfa[j][a];
                        if (p == q) continue;
                        if (p > q) { int temp = p; p = q; q = temp; }
                        if (distinguishable[q][p]) {
                            distinguishable[i][j] = 1;
                            changed = 1;
                            break;
                        }
                    }
                }
            }
        }
    } while (changed);
}

// Step 3: Build minimized DFA
void build_minimized_dfa() {
    int group[MAX] = {-1}; // group[i] = representative of i
    int new_state[MAX] = {-1};
    int new_dfa[MAX][MAX];
    int new_final[MAX] = {0};
    int new_count = 0;

    for (int i = 0; i < state_count; i++) {
        if (!reachable[i]) continue;
        if (group[i] != -1) continue;

        group[i] = i;
        for (int j = 0; j < i; j++) {
            if (!reachable[j]) continue;
            if (!distinguishable[i][j]) {
                group[j] = i;
            }
        }
        new_state[i] = new_count++;
    }

    // Build new DFA
    for (int i = 0; i < state_count; i++) {
        if (group[i] != i) continue;
        int rep = i;
        for (int a = 0; a < symbol_count; a++) {
            int target = dfa[rep][a];
            new_dfa[new_state[rep]][a] = new_state[group[target]];
        }
        if (final[rep]) new_final[new_state[rep]] = 1;
    }

    // Print minimized DFA
    printf("\nMinimized DFA Transition Table:\n");
    for (int i = 0; i < new_count; i++) {
        printf("State %d%s: ", i, new_final[i] ? " (final)" : "");
        for (int a = 0; a < symbol_count; a++) {
            printf(" --%d--> %d ", a, new_dfa[i][a]);
        }
        printf("\n");
    }
}

int main() {
    printf("Enter number of DFA states: ");
    scanf("%d", &state_count);

    printf("Enter number of input symbols: ");
    scanf("%d", &symbol_count);

    printf("Enter DFA transition table:\n");
    for (int i = 0; i < state_count; i++) {
        for (int a = 0; a < symbol_count; a++) {
            printf("From q%d on symbol %d: ", i, a);
            scanf("%d", &dfa[i][a]);
        }
    }

    printf("Enter final states (1 for final, 0 for non-final):\n");
    for (int i = 0; i < state_count; i++) {
        printf("Is q%d final? ", i);
        scanf("%d", &final[i]);
    }

    find_reachable();
    mark_distinguishable();
    build_minimized_dfa();

    return 0;
} 
