#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STATES 20
#define MAX_ALPHA 20
#define MAX_DFA_STATES 20   /* increase if you expect more DFA states */

struct node {
    int st;
    struct node* link;
};

struct dstate {
    int nst[MAX_STATES + 1]; /* 1..nostate used */
};

int nostate, noalpha, notransition, nofinal, start;
char alphabet[MAX_ALPHA];
int finalstate[MAX_STATES + 1];
struct node* transition[MAX_STATES + 1][MAX_ALPHA];
struct dstate hash[MAX_DFA_STATES];
int complete = -1; /* index of last DFA state stored (0-based) */

int compare(const struct dstate *a, const struct dstate *b) {
    for (int i = 1; i <= nostate; ++i)
        if (a->nst[i] != b->nst[i]) return 0;
    return 1;
}

int insertDfaState(struct dstate newstate) {
    for (int i = 0; i <= complete; ++i)
        if (compare(&hash[i], &newstate)) return 0; /* already present */

    if (complete + 1 >= MAX_DFA_STATES) {
        fprintf(stderr, "Error: DFA-state storage limit (%d) exceeded. Increase MAX_DFA_STATES.\n", MAX_DFA_STATES);
        exit(EXIT_FAILURE);
    }
    complete++;
    hash[complete] = newstate;
    return 1;
}

int findalpha(char c) {
    for (int i = 0; i < noalpha; ++i)
        if (alphabet[i] == c) return i;
    return -1;
}

void insertTransition(int from, char ch, int to) {
    int idx = findalpha(ch);
    if (idx == -1) {
        fprintf(stderr, "Error: symbol '%c' not found in alphabet.\n", ch);
        exit(EXIT_FAILURE);
    }
    struct node* temp = malloc(sizeof(struct node));
    if (!temp) { perror("malloc"); exit(EXIT_FAILURE); }
    temp->st = to;
    temp->link = transition[from][idx];
    transition[from][idx] = temp;
}

void printSet(const struct dstate *s) {
    int first = 1;
    printf("{");
    for (int j = 1; j <= nostate; ++j) {
        if (s->nst[j]) {
            if (!first) printf(",");
            printf("q%d", j);
            first = 0;
        }
    }
    printf("}");
}

void printAllFinalDfaStates() {
    printf("\nFinal DFA states (contain NFA final states):\n");
    for (int i = 0; i <= complete; ++i) {
        for (int f = 0; f < nofinal; ++f) {
            if (hash[i].nst[ finalstate[f] ]) {
                printf("D%d: ", i);
                printSet(&hash[i]);
                printf("\n");
                break;
            }
        }
    }
}

int main(void) {
    int from, to;
    char ch;

    /* init */
    memset(transition, 0, sizeof(transition));
    memset(hash, 0, sizeof(hash));

    printf("Enter the number of alphabets: ");
    if (scanf("%d", &noalpha) != 1) return 0;
    printf("Enter the alphabets (separated by space or newline):\n");
    for (int i = 0; i < noalpha; ++i) {
        scanf(" %c", &alphabet[i]); /* leading space to skip whitespace/newline */
    }

    printf("Enter the number of states: ");
    scanf("%d", &nostate);
    printf("Enter the start state (1..%d): ", nostate);
    scanf("%d", &start);

    printf("Enter the number of final states: ");
    scanf("%d", &nofinal);
    printf("Enter the final states (space separated):\n");
    for (int i = 0; i < nofinal; ++i) scanf("%d", &finalstate[i]);

    printf("Enter the number of transitions: ");
    scanf("%d", &notransition);
    printf("Enter transitions one per line in format: from symbol to  (e.g. 1 a 2)\n");
    for (int i = 0; i < notransition; ++i) {
        scanf("%d %c %d", &from, &ch, &to);
        insertTransition(from, ch, to);
    }

    /* ---- Subset construction ---- */
    struct dstate newstate, tmpstate;
    for (int j = 1; j <= nostate; ++j) newstate.nst[j] = 0;
    newstate.nst[start] = start;    /* initial DFA state = {start} */
    insertDfaState(newstate);

    int i = 0;
    printf("\nEquivalent DFA (subset construction):\n");
    while (i <= complete) {
        printf("D%d: ", i); printSet(&hash[i]); printf("\n");

        for (int k = 0; k < noalpha; ++k) {
            int set[MAX_STATES + 1] = {0};

            /* clear tmpstate */
            for (int m = 1; m <= nostate; ++m) tmpstate.nst[m] = 0;

            /* for each NFA-state present in current DFA-state, follow transitions on alphabet[k] */
            for (int j = 1; j <= nostate; ++j) {
                if (hash[i].nst[j]) {
                    struct node* t = transition[j][k];
                    while (t) {
                        set[t->st] = 1; /* mark reachable NFA state */
                        t = t->link;
                    }
                }
            }

            int nonEmpty = 0;
            for (int m = 1; m <= nostate; ++m) {
                if (set[m]) { tmpstate.nst[m] = m; nonEmpty = 1; }
                else tmpstate.nst[m] = 0;
            }

            printf("  on %c -> ", alphabet[k]);
            if (!nonEmpty) {
                printf("NULL\n");
            } else {
                insertDfaState(tmpstate);    /* adds only if new */
                printSet(&tmpstate);
                printf("\n");
            }
        }
        i++;
    }

    printf("\nAll DFA states discovered:\n");
    for (int idx = 0; idx <= complete; ++idx) {
        printf("D%d: ", idx); printSet(&hash[idx]); printf("\n");
    }

    printf("\nAlphabets: ");
    for (int a = 0; a < noalpha; ++a) printf("%c ", alphabet[a]);
    printf("\nStart state: D0 (which is {q%d})\n", start);

    printAllFinalDfaStates();

    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STATES 10
#define MAX_SYMBOLS 10
#define MAX_DFA_STATES 50

int nfa[MAX_STATES][MAX_SYMBOLS + 1][MAX_STATES]; // +1 for epsilon
int nfa_count[MAX_STATES][MAX_SYMBOLS + 1];
int nfa_states, symbols;

int dfa[MAX_DFA_STATES][MAX_SYMBOLS];
int dfa_state_sets[MAX_DFA_STATES][MAX_STATES];
int dfa_set_size[MAX_DFA_STATES];
int dfa_total = 0;

int inSet(int set[], int size, int val) {
    for (int i = 0; i < size; i++)
        if (set[i] == val) return 1;
    return 0;
}

void epsilonClosure(int state, int closure[], int *size) {
    if (!inSet(closure, *size, state)) {
        closure[(*size)++] = state;
        for (int i = 0; i < nfa_count[state][symbols]; i++) {
            int next = nfa[state][symbols][i];
            epsilonClosure(next, closure, size);
        }
    }
}

void epsilonClosureSet(int set[], int size, int closure[], int *closureSize) {
    *closureSize = 0;
    for (int i = 0; i < size; i++)
        epsilonClosure(set[i], closure, closureSize);
}

int equalSets(int a[], int b[], int sizeA, int sizeB) {
    if (sizeA != sizeB) return 0;
    for (int i = 0; i < sizeA; i++)
        if (!inSet(b, sizeB, a[i])) return 0;
    return 1;
}

int findSetIndex(int set[], int size) {
    for (int i = 0; i < dfa_total; i++)
        if (equalSets(set, dfa_state_sets[i], size, dfa_set_size[i])) return i;
    return -1;
}

void printDFA() {
    printf("\nDFA Transition Table:\n");
    printf("State\\Symbol");
    for (int i = 0; i < symbols; i++) printf("\t%c", 'a' + i);
    printf("\n");

    for (int i = 0; i < dfa_total; i++) {
        printf("D%d\t\t", i);
        for (int j = 0; j < symbols; j++) {
            if (dfa[i][j] == -1) printf("-\t");
            else printf("D%d\t", dfa[i][j]);
        }
        printf("\n");
    }
}

int main() {
    printf("Enter number of NFA states: ");
    scanf("%d", &nfa_states);
    printf("Enter number of input symbols: ");
    scanf("%d", &symbols);

    memset(nfa_count, 0, sizeof(nfa_count));
    memset(dfa, -1, sizeof(dfa));

    printf("Enter transitions (from symbol to), use 'e' for epsilon. Enter -1 - -1 to stop:\n");
    int from, to;
    char sym;
    while (1) {
        scanf("%d %c %d", &from, &sym, &to);
        if (from == -1) break;
        int index = (sym == 'e') ? symbols : sym - 'a';
        nfa[from][index][nfa_count[from][index]++] = to;
    }

    int startSet[MAX_STATES], startSize = 0;
    epsilonClosure(0, startSet, &startSize);
    memcpy(dfa_state_sets[0], startSet, sizeof(int) * startSize);
    dfa_set_size[0] = startSize;
    dfa_total = 1;

    int front = 0;
    while (front < dfa_total) {
        int *currentSet = dfa_state_sets[front];
        int currentSize = dfa_set_size[front];

        for (int s = 0; s < symbols; s++) {
            int moveSet[MAX_STATES], moveSize = 0;

            for (int i = 0; i < currentSize; i++) {
                int state = currentSet[i];
                for (int j = 0; j < nfa_count[state][s]; j++) {
                    int next = nfa[state][s][j];
                    if (!inSet(moveSet, moveSize, next))
                        moveSet[moveSize++] = next;
                }
            }

            int closure[MAX_STATES], closureSize;
            epsilonClosureSet(moveSet, moveSize, closure, &closureSize);

            if (closureSize == 0) continue;

            int idx = findSetIndex(closure, closureSize);
            if (idx == -1) {
                idx = dfa_total++;
                memcpy(dfa_state_sets[idx], closure, sizeof(int) * closureSize);
                dfa_set_size[idx] = closureSize;
            }
            dfa[front][s] = idx;
        }
        front++;
    }

    printDFA();
    return 0;
}
