#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_STATES 10 
#define MAX_SYMBOLS 10 
#define MAX_DFA_STATES 100 
int nfa[MAX_STATES][MAX_SYMBOLS][MAX_STATES]; 
int nfaCount[MAX_STATES][MAX_SYMBOLS]; 
int nfaStates, symbolsCount; 
char symbols[MAX_SYMBOLS]; 
// DFA state representation 
int dfaStates[MAX_DFA_STATES][MAX_STATES]; // Each DFA state is a set of NFA states int dfaStateCount = 0; 
int dfaTrans[MAX_DFA_STATES][MAX_SYMBOLS]; 
int isSameState(int a[], int b[]) { 
for (int i = 0; i < nfaStates; i++) { 
if (a[i] != b[i]) return 0; 
} 
return 1; 
} 
int stateExists(int stateSet[][MAX_STATES], int count, int state[]) { 
for (int i = 0; i < count; i++) { 
if (isSameState(stateSet[i], state)) return i; 
} 
return -1; 
} 
void addToSet(int set[], int val) { 
if (!set[val]) 
set[val] = 1; 
} 
void printDFA() { 
printf("\nDFA Transition Table:\n"); 
for (int i = 0; i < dfaStateCount; i++) { 
printf("DFA state %d:", i); 
for (int k = 0; k < symbolsCount; k++) { 
printf(" --%c--> %d", symbols[k], dfaTrans[i][k]);
} 
printf("\n"); 
} 
} 
int main() { 
printf("Enter number of NFA states: "); 
scanf("%d", &nfaStates); 
printf("Enter number of input symbols: "); 
scanf("%d", &symbolsCount); 
printf("Enter the input symbols: "); 
for (int i = 0; i < symbolsCount; i++) { 
scanf(" %c", &symbols[i]); 
} 
int nTransitions; 
printf("Enter number of NFA transitions: "); 
scanf("%d", &nTransitions); 
printf("Enter transitions (from_state symbol to_state):\n"); 
for (int i = 0; i < nTransitions; i++) { 
int from, to; 
char sym; 
scanf("%d %c %d", &from, &sym, &to); 
int symIdx = -1; 
for (int j = 0; j < symbolsCount; j++) { 
if (symbols[j] == sym) { 
symIdx = j; 
break; 
} 
} 
if (symIdx != -1) { 
nfa[from][symIdx][nfaCount[from][symIdx]++] = to; } else { 
printf("Invalid symbol.\n"); 
return 1; 
} 
} 
// Initial DFA state is NFA state 0 
int initial[MAX_STATES] = {0}; 
initial[0] = 1; 
memcpy(dfaStates[0], initial, sizeof(initial));
dfaStateCount = 1; 
for (int i = 0; i < dfaStateCount; i++) { 
for (int k = 0; k < symbolsCount; k++) { 
int newSet[MAX_STATES] = {0}; 
// For each NFA state in the current DFA state 
for (int s = 0; s < nfaStates; s++) { 
if (dfaStates[i][s]) { 
for (int t = 0; t < nfaCount[s][k]; t++) { 
addToSet(newSet, nfa[s][k][t]); 
} 
} 
} 
int existingIndex = stateExists(dfaStates, dfaStateCount, newSet); if (existingIndex == -1) { 
memcpy(dfaStates[dfaStateCount], newSet, sizeof(newSet)); dfaTrans[i][k] = dfaStateCount; 
dfaStateCount++; 
} else { 
dfaTrans[i][k] = existingIndex; 
} 
} 
} 
printDFA(); 
return 0; 
}
*********************************************
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STATES 10
#define MAX_SYMBOLS 10
#define MAX_DFA_STATES 50

int nfa[MAX_STATES][MAX_SYMBOLS + 1][MAX_STATES]; // +1 for epsilon
int nfa_count[MAX_STATES][MAX_SYMBOLS + 1];
int nfa_states, symbols;

int dfa[MAX_DFA_STATES][MAX_SYMBOLS];
int dfa_state_sets[MAX_DFA_STATES][MAX_STATES];
int dfa_set_size[MAX_DFA_STATES];
int dfa_total = 0;

int inSet(int set[], int size, int val) {
    for (int i = 0; i < size; i++)
        if (set[i] == val) return 1;
    return 0;
}

void epsilonClosure(int state, int closure[], int *size) {
    if (!inSet(closure, *size, state)) {
        closure[(*size)++] = state;
        for (int i = 0; i < nfa_count[state][symbols]; i++) {
            int next = nfa[state][symbols][i];
            epsilonClosure(next, closure, size);
        }
    }
}

void epsilonClosureSet(int set[], int size, int closure[], int *closureSize) {
    *closureSize = 0;
    for (int i = 0; i < size; i++)
        epsilonClosure(set[i], closure, closureSize);
}

int equalSets(int a[], int b[], int sizeA, int sizeB) {
    if (sizeA != sizeB) return 0;
    for (int i = 0; i < sizeA; i++)
        if (!inSet(b, sizeB, a[i])) return 0;
    return 1;
}

int findSetIndex(int set[], int size) {
    for (int i = 0; i < dfa_total; i++)
        if (equalSets(set, dfa_state_sets[i], size, dfa_set_size[i])) return i;
    return -1;
}

void printDFA() {
    printf("\nDFA Transition Table:\n");
    printf("State\\Symbol");
    for (int i = 0; i < symbols; i++) printf("\t%c", 'a' + i);
    printf("\n");

    for (int i = 0; i < dfa_total; i++) {
        printf("D%d\t\t", i);
        for (int j = 0; j < symbols; j++) {
            if (dfa[i][j] == -1) printf("-\t");
            else printf("D%d\t", dfa[i][j]);
        }
        printf("\n");
    }
}

int main() {
    printf("Enter number of NFA states: ");
    scanf("%d", &nfa_states);
    printf("Enter number of input symbols: ");
    scanf("%d", &symbols);

    memset(nfa_count, 0, sizeof(nfa_count));
    memset(dfa, -1, sizeof(dfa));

    printf("Enter transitions (from symbol to), use 'e' for epsilon. Enter -1 - -1 to stop:\n");
    int from, to;
    char sym;
    while (1) {
        scanf("%d %c %d", &from, &sym, &to);
        if (from == -1) break;
        int index = (sym == 'e') ? symbols : sym - 'a';
        nfa[from][index][nfa_count[from][index]++] = to;
    }

    int startSet[MAX_STATES], startSize = 0;
    epsilonClosure(0, startSet, &startSize);
    memcpy(dfa_state_sets[0], startSet, sizeof(int) * startSize);
    dfa_set_size[0] = startSize;
    dfa_total = 1;

    int front = 0;
    while (front < dfa_total) {
        int *currentSet = dfa_state_sets[front];
        int currentSize = dfa_set_size[front];

        for (int s = 0; s < symbols; s++) {
            int moveSet[MAX_STATES], moveSize = 0;

            for (int i = 0; i < currentSize; i++) {
                int state = currentSet[i];
                for (int j = 0; j < nfa_count[state][s]; j++) {
                    int next = nfa[state][s][j];
                    if (!inSet(moveSet, moveSize, next))
                        moveSet[moveSize++] = next;
                }
            }

            int closure[MAX_STATES], closureSize;
            epsilonClosureSet(moveSet, moveSize, closure, &closureSize);

            if (closureSize == 0) continue;

            int idx = findSetIndex(closure, closureSize);
            if (idx == -1) {
                idx = dfa_total++;
                memcpy(dfa_state_sets[idx], closure, sizeof(int) * closureSize);
                dfa_set_size[idx] = closureSize;
            }
            dfa[front][s] = idx;
        }
        front++;
    }

    printDFA();
    return 0;
}
