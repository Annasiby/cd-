#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STATES 20
#define MAX_ALPHA 20
#define MAX_DFA_STATES 20   /* increase if you expect more DFA states */

struct node {
    int st;
    struct node* link;
};

struct dstate {
    int nst[MAX_STATES + 1]; /* 1..nostate used */
};

int nostate, noalpha, notransition, nofinal, start;
char alphabet[MAX_ALPHA];
int finalstate[MAX_STATES + 1];
struct node* transition[MAX_STATES + 1][MAX_ALPHA];
struct dstate hash[MAX_DFA_STATES];
int complete = -1; /* index of last DFA state stored (0-based) */

int compare(const struct dstate *a, const struct dstate *b) {
    for (int i = 1; i <= nostate; ++i)
        if (a->nst[i] != b->nst[i]) return 0;
    return 1;
}

int insertDfaState(struct dstate newstate) {
    for (int i = 0; i <= complete; ++i)
        if (compare(&hash[i], &newstate)) return 0; /* already present */

    if (complete + 1 >= MAX_DFA_STATES) {
        fprintf(stderr, "Error: DFA-state storage limit (%d) exceeded. Increase MAX_DFA_STATES.\n", MAX_DFA_STATES);
        exit(EXIT_FAILURE);
    }
    complete++;
    hash[complete] = newstate;
    return 1;
}

int findalpha(char c) {
    for (int i = 0; i < noalpha; ++i)
        if (alphabet[i] == c) return i;
    return -1;
}

void insertTransition(int from, char ch, int to) {
    int idx = findalpha(ch);
    if (idx == -1) {
        fprintf(stderr, "Error: symbol '%c' not found in alphabet.\n", ch);
        exit(EXIT_FAILURE);
    }
    struct node* temp = malloc(sizeof(struct node));
    if (!temp) { perror("malloc"); exit(EXIT_FAILURE); }
    temp->st = to;
    temp->link = transition[from][idx];
    transition[from][idx] = temp;
}

void printSet(const struct dstate *s) {
    int first = 1;
    printf("{");
    for (int j = 1; j <= nostate; ++j) {
        if (s->nst[j]) {
            if (!first) printf(",");
            printf("q%d", j);
            first = 0;
        }
    }
    printf("}");
}

void printAllFinalDfaStates() {
    printf("\nFinal DFA states (contain NFA final states):\n");
    for (int i = 0; i <= complete; ++i) {
        for (int f = 0; f < nofinal; ++f) {
            if (hash[i].nst[ finalstate[f] ]) {
                printf("D%d: ", i);
                printSet(&hash[i]);
                printf("\n");
                break;
            }
        }
    }
}

int main(void) {
    int from, to;
    char ch;

    /* init */
    memset(transition, 0, sizeof(transition));
    memset(hash, 0, sizeof(hash));

    printf("Enter the number of alphabets: ");
    if (scanf("%d", &noalpha) != 1) return 0;
    printf("Enter the alphabets (separated by space or newline):\n");
    for (int i = 0; i < noalpha; ++i) {
        scanf(" %c", &alphabet[i]); /* leading space to skip whitespace/newline */
    }

    printf("Enter the number of states: ");
    scanf("%d", &nostate);
    printf("Enter the start state (1..%d): ", nostate);
    scanf("%d", &start);

    printf("Enter the number of final states: ");
    scanf("%d", &nofinal);
    printf("Enter the final states (space separated):\n");
    for (int i = 0; i < nofinal; ++i) scanf("%d", &finalstate[i]);

    printf("Enter the number of transitions: ");
    scanf("%d", &notransition);
    printf("Enter transitions one per line in format: from symbol to  (e.g. 1 a 2)\n");
    for (int i = 0; i < notransition; ++i) {
        scanf("%d %c %d", &from, &ch, &to);
        insertTransition(from, ch, to);
    }

    /* ---- Subset construction ---- */
    struct dstate newstate, tmpstate;
    for (int j = 1; j <= nostate; ++j) newstate.nst[j] = 0;
    newstate.nst[start] = start;    /* initial DFA state = {start} */
    insertDfaState(newstate);

    int i = 0;
    printf("\nEquivalent DFA (subset construction):\n");
    while (i <= complete) {
        printf("D%d: ", i); printSet(&hash[i]); printf("\n");

        for (int k = 0; k < noalpha; ++k) {
            int set[MAX_STATES + 1] = {0};

            /* clear tmpstate */
            for (int m = 1; m <= nostate; ++m) tmpstate.nst[m] = 0;

            /* for each NFA-state present in current DFA-state, follow transitions on alphabet[k] */
            for (int j = 1; j <= nostate; ++j) {
                if (hash[i].nst[j]) {
                    struct node* t = transition[j][k];
                    while (t) {
                        set[t->st] = 1; /* mark reachable NFA state */
                        t = t->link;
                    }
                }
            }

            int nonEmpty = 0;
            for (int m = 1; m <= nostate; ++m) {
                if (set[m]) { tmpstate.nst[m] = m; nonEmpty = 1; }
                else tmpstate.nst[m] = 0;
            }

            printf("  on %c -> ", alphabet[k]);
            if (!nonEmpty) {
                printf("NULL\n");
            } else {
                insertDfaState(tmpstate);    /* adds only if new */
                printSet(&tmpstate);
                printf("\n");
            }
        }
        i++;
    }

    printf("\nAll DFA states discovered:\n");
    for (int idx = 0; idx <= complete; ++idx) {
        printf("D%d: ", idx); printSet(&hash[idx]); printf("\n");
    }

    printf("\nAlphabets: ");
    for (int a = 0; a < noalpha; ++a) printf("%c ", alphabet[a]);
    printf("\nStart state: D0 (which is {q%d})\n", start);

    printAllFinalDfaStates();

    return 0;
}

